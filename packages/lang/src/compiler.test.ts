import { Compiler, CompilerError, CompilerErrorCode } from "./compiler";
import { Atom, Parser, Tuple } from "./parser";
import { Program, Clause } from "./program";
import { ResultError, ResultValue } from "./result";
import { Stream } from "./stream";

describe('Compiler', () => {
  it('should return error when compiling identity clause', () => {
    const code = "a";
    const stream = new Stream(code, 0);
    const parser = new Parser();
    const parserResult = parser.parse(stream) as ResultValue<Atom[]>;
    expect(parserResult.value.length).toBe(1);
    const atoms = parserResult.value;
    const compiler = new Compiler();
    const compilerResult = compiler.compile(atoms) as ResultError<CompilerError>;
    const error = compilerResult.error;
    expect(error.code).toBe(CompilerErrorCode.IdentifierAsClause);
    expect(error.atom).toBe(atoms[0]);
  });

  it('should return error when compiling variable clause', () => {
    const code = "A";
    const stream = new Stream(code, 0);
    const parser = new Parser();
    const parserResult = parser.parse(stream) as ResultValue<Atom[]>;
    expect(parserResult.value.length).toBe(1);
    const atoms = parserResult.value;
    const compiler = new Compiler();
    const compilerResult = compiler.compile(atoms) as ResultError<CompilerError>;
    const error = compilerResult.error;
    expect(error.code).toBe(CompilerErrorCode.VariableAsClause);
    expect(error.atom).toBe(atoms[0]);
  });

  it('should return empty program for empty tuple', () => {
    const code = "()";
    const stream = new Stream(code, 0);
    const parser = new Parser();
    const parserResult = parser.parse(stream) as ResultValue<Atom[]>;
    expect(parserResult.value.length).toBe(1);
    const atoms = parserResult.value;
    const compiler = new Compiler();
    const compilerResult = compiler.compile(atoms) as ResultValue<Program>;
    const program: Program = compilerResult.value;
    expect(program.cells.length).toBe(0);
    expect(program.clauses.size).toBe(0);
    expect(program.symbols.length).toBe(0);
  });

  it('should return error when functor is variable', () => {
    const code = "(A)";
    const stream = new Stream(code, 0);
    const parser = new Parser();
    const parserResult = parser.parse(stream) as ResultValue<Atom[]>;
    expect(parserResult.value.length).toBe(1);
    const atoms = parserResult.value;
    const compiler = new Compiler();
    const compilerResult = compiler.compile(atoms) as ResultError<CompilerError>;
    const error = compilerResult.error;
    expect(error.code).toBe(CompilerErrorCode.VariableAsFunctor);
    const tuple = atoms[0] as Tuple;
    expect(error.atom).toBe(tuple.atoms[0]);
  });

  it('should return error when functor is tuple', () => {
    const code = "(())";
    const stream = new Stream(code, 0);
    const parser = new Parser();
    const parserResult = parser.parse(stream) as ResultValue<Atom[]>;
    expect(parserResult.value.length).toBe(1);
    const atoms = parserResult.value;
    const compiler = new Compiler();
    const compilerResult = compiler.compile(atoms) as ResultError<CompilerError>;
    const error = compilerResult.error;
    expect(error.code).toBe(CompilerErrorCode.TupleAsFunctor);
    const tuple = atoms[0] as Tuple;
    expect(error.atom).toBe(tuple.atoms[0]);
  });

  it('should return program for monad tuple', () => {
    const code = "(a)";
    const stream = new Stream(code, 0);
    const parser = new Parser();
    const parserResult = parser.parse(stream) as ResultValue<Atom[]>;
    expect(parserResult.value.length).toBe(1);
    const atoms = parserResult.value;
    const compiler = new Compiler();
    const compilerResult = compiler.compile(atoms) as ResultValue<Program>;
    const program: Program = compilerResult.value;
    expect(program.cells.length).toBe(2);
    expect(program.cells[0]).toBe(5);
    expect(program.cells[1]).toBe(3);
    expect(program.symbols.length).toBe(1);
    expect(program.symbols[0]).toBe('a');
    expect(program.clauses.size).toBe(1);
    const clauses = program.clauses.get('a/0') as Clause[];
    expect(clauses.length).toBe(1);
    const clause = clauses[0];
    expect(clause.addr).toBe(0);
    expect(clause.len).toBe(2);
    expect(clause.neckAdd).toBe(2);
    expect(clause.headAddr).toBe(0);
    expect(clause.goalAddrs.length).toBe(0);
    expect(clause.xs.length).toBe(0);
  });

  it('should return program for tuple with no predicates', () => {
    const code = "(a ())";
    const stream = new Stream(code, 0);
    const parser = new Parser();
    const parserResult = parser.parse(stream) as ResultValue<Atom[]>;
    expect(parserResult.value.length).toBe(1);
    const atoms = parserResult.value;
    const compiler = new Compiler();
    const compilerResult = compiler.compile(atoms) as ResultValue<Program>;
    const program: Program = compilerResult.value;
    expect(program.cells.length).toBe(2);
    expect(program.cells[0]).toBe(5);
    expect(program.cells[1]).toBe(3);
    expect(program.symbols.length).toBe(1);
    expect(program.symbols[0]).toBe('a');
    expect(program.clauses.size).toBe(1);
    const clauses = program.clauses.get('a/0') as Clause[];
    expect(clauses.length).toBe(1);
    const clause = clauses[0];
    expect(clause.addr).toBe(0);
    expect(clause.len).toBe(2);
    expect(clause.neckAdd).toBe(2);
    expect(clause.headAddr).toBe(0);
    expect(clause.goalAddrs.length).toBe(0);
    expect(clause.xs.length).toBe(0);
  });

  it('should return program for tuple with single-elem tuple arg', () => {
    const code = "(a (b))";
    const stream = new Stream(code, 0);
    const parser = new Parser();
    const parserResult = parser.parse(stream) as ResultValue<Atom[]>;
    expect(parserResult.value.length).toBe(1);
    const atoms = parserResult.value;
    const compiler = new Compiler();
    const compilerResult = compiler.compile(atoms) as ResultValue<Program>;
    const program: Program = compilerResult.value;
    expect(program.cells.length).toBe(3);
    expect(program.cells[0]).toBe(13);
    expect(program.cells[1]).toBe(3);
    expect(program.cells[2]).toBe(11);
    expect(program.symbols.length).toBe(2);
    expect(program.symbols[0]).toBe('a');
    expect(program.symbols[1]).toBe('b');
    expect(program.clauses.size).toBe(1);
    const clauses = program.clauses.get('a/1') as Clause[];
    expect(clauses.length).toBe(1);
    const clause = clauses[0];
    expect(clause.addr).toBe(0);
    expect(clause.len).toBe(3);
    expect(clause.neckAdd).toBe(3);
    expect(clause.headAddr).toBe(0);
    expect(clause.goalAddrs.length).toBe(0);
    expect(clause.xs.length).toBe(0);
  });

  it('should return program for tuple with single-elem tuple arg', () => {
    const code = "(a (B))";
    const stream = new Stream(code, 0);
    const parser = new Parser();
    const parserResult = parser.parse(stream) as ResultValue<Atom[]>;
    expect(parserResult.value.length).toBe(1);
    const atoms = parserResult.value;
    const compiler = new Compiler();
    const compilerResult = compiler.compile(atoms) as ResultValue<Program>;
    const program: Program = compilerResult.value;
    expect(program.cells.length).toBe(3);
    expect(program.cells[0]).toBe(13);
    expect(program.cells[1]).toBe(3);
    expect(program.cells[2]).toBe(16);
    expect(program.symbols.length).toBe(1);
    expect(program.symbols[0]).toBe('a');
    expect(program.clauses.size).toBe(1);
    const clauses = program.clauses.get('a/1') as Clause[];
    expect(clauses.length).toBe(1);
    const clause = clauses[0];
    expect(clause.addr).toBe(0);
    expect(clause.len).toBe(3);
    expect(clause.neckAdd).toBe(3);
    expect(clause.headAddr).toBe(0);
    expect(clause.goalAddrs.length).toBe(0);
    expect(clause.xs.length).toBe(0);
  });

  it('should return program for tuple with tuple predicates', () => {
    const code = "(a (b B (c (B))))";
    const stream = new Stream(code, 0);
    const parser = new Parser();
    const parserResult = parser.parse(stream) as ResultValue<Atom[]>;
    expect(parserResult.value.length).toBe(1);
    const atoms = parserResult.value;
    const compiler = new Compiler();
    const compilerResult = compiler.compile(atoms) as ResultValue<Program>;
    const program: Program = compilerResult.value;
    expect(program.cells.length).toBe(8);
    expect(program.cells[0]).toBe(29);
    expect(program.cells[1]).toBe(3);
    expect(program.cells[2]).toBe(11);
    expect(program.cells[3]).toBe(24);
    expect(program.cells[4]).toBe(42);
    expect(program.cells[5]).toBe(13);
    expect(program.cells[6]).toBe(19);
    expect(program.cells[7]).toBe(25);
    expect(program.symbols.length).toBe(3);
    expect(program.symbols[0]).toBe('a');
    expect(program.symbols[1]).toBe('b');
    expect(program.symbols[2]).toBe('c');
    expect(program.clauses.size).toBe(1);
    const clauses = program.clauses.get('a/3') as Clause[];
    expect(clauses.length).toBe(1);
    const clause = clauses[0];
    expect(clause.addr).toBe(0);
    expect(clause.len).toBe(8);
    expect(clause.headAddr).toBe(0);
    expect(clause.neckAdd).toBe(8);
    expect(clause.goalAddrs.length).toBe(0);
    expect(clause.xs.length).toBe(0);
  });

  it('should return program for tuple with tuple predicates', () => {
    const code = "(a (b B (c (B))) ((a (b c B))))";
    const stream = new Stream(code, 0);
    const parser = new Parser();
    const parserResult = parser.parse(stream) as ResultValue<Atom[]>;
    expect(parserResult.value.length).toBe(1);
    const atoms = parserResult.value;
    const compiler = new Compiler();
    const compilerResult = compiler.compile(atoms) as ResultValue<Program>;
    const program: Program = compilerResult.value;
    expect(program.cells.length).toBe(13);
    expect(program.cells[0]).toBe(29);
    expect(program.cells[1]).toBe(3);
    expect(program.cells[2]).toBe(11);
    expect(program.cells[3]).toBe(24);
    expect(program.cells[4]).toBe(42);
    expect(program.cells[5]).toBe(13);
    expect(program.cells[6]).toBe(19);
    expect(program.cells[7]).toBe(25);
    expect(program.cells[8]).toBe(29);
    expect(program.cells[9]).toBe(3);
    expect(program.cells[10]).toBe(11);
    expect(program.cells[11]).toBe(19);
    expect(program.cells[12]).toBe(25);
    expect(program.symbols.length).toBe(3);
    expect(program.symbols[0]).toBe('a');
    expect(program.symbols[1]).toBe('b');
    expect(program.symbols[2]).toBe('c');
    expect(program.clauses.size).toBe(1);
    const clauses = program.clauses.get('a/3') as Clause[];
    expect(clauses.length).toBe(1);
    const clause = clauses[0];
    expect(clause.addr).toBe(0);
    expect(clause.len).toBe(13);
    expect(clause.headAddr).toBe(0);
    expect(clause.neckAdd).toBe(8);
    expect(clause.goalAddrs.length).toBe(1);
    expect(clause.goalAddrs[0]).toBe(8);
    expect(clause.xs.length).toBe(0);
  });

  it('should return program for muitiple tuples', () => {
    const code = "(a (b c d)) (add ((s (X)) Y (s (Z))) ((add (X Y Z))))";
    const stream = new Stream(code, 0);
    const parser = new Parser();
    const parserResult = parser.parse(stream) as ResultValue<Atom[]>;
    expect(parserResult.value.length).toBe(2);
    const atoms = parserResult.value;
    const compiler = new Compiler();
    const compilerResult = compiler.compile(atoms) as ResultValue<Program>;
    const program: Program = compilerResult.value;
    expect(program.cells.length).toBe(21);
    expect(program.cells[0]).toBe(29);
    expect(program.cells[1]).toBe(3);
    expect(program.cells[2]).toBe(11);
    expect(program.cells[3]).toBe(19);
    expect(program.cells[4]).toBe(27);
    expect(program.cells[5]).toBe(29);
    expect(program.cells[6]).toBe(35);
    expect(program.cells[7]).toBe(82);
    expect(program.cells[8]).toBe(64);
    expect(program.cells[9]).toBe(106);
    expect(program.cells[10]).toBe(13);
    expect(program.cells[11]).toBe(43);
    expect(program.cells[12]).toBe(96);
    expect(program.cells[13]).toBe(13);
    expect(program.cells[14]).toBe(43);
    expect(program.cells[15]).toBe(120);
    expect(program.cells[16]).toBe(29);
    expect(program.cells[17]).toBe(35);
    expect(program.cells[18]).toBe(97);
    expect(program.cells[19]).toBe(65);
    expect(program.cells[20]).toBe(121);
    expect(program.symbols.length).toBe(6);
    expect(program.symbols[0]).toBe('a');
    expect(program.symbols[1]).toBe('b');
    expect(program.symbols[2]).toBe('c');
    expect(program.symbols[3]).toBe('d');
    expect(program.symbols[4]).toBe('add');
    expect(program.symbols[5]).toBe('s');
    expect(program.clauses.size).toBe(2);
    const firstClauses = program.clauses.get('a/3') as Clause[];
    expect(firstClauses.length).toBe(1);
    const firstClause = firstClauses[0];
    expect(firstClause.addr).toBe(0);
    expect(firstClause.len).toBe(5);
    expect(firstClause.headAddr).toBe(0);
    expect(firstClause.neckAdd).toBe(5);
    expect(firstClause.goalAddrs.length).toBe(0);
    expect(firstClause.xs.length).toBe(0);
    const sndClauses = program.clauses.get('add/3') as Clause[];
    expect(sndClauses.length).toBe(1);
    const sndClause = sndClauses[0];
    expect(sndClause.addr).toBe(5);
    expect(sndClause.len).toBe(16);
    expect(sndClause.headAddr).toBe(5);
    expect(sndClause.neckAdd).toBe(16);
    expect(sndClause.goalAddrs.length).toBe(1);
    expect(sndClause.goalAddrs[0]).toBe(16);
    expect(sndClause.xs.length).toBe(0);
  });
})